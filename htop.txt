This is an example of what Htop might look like. It uses a fake (inconsistent)
syntax for describing the schema/type of htop. A similar syntax is used for
sending the actual data.

Try not to focus too hard on the syntax. Instead, focus on the semantics of the
various statements. Although it won't be consistent either, it should be useful.

There are two main goals with this format:

1. The schema should look like something you would create in a backend with very
little of the layout/style poking through.

2. The schema should preserve the developers intention. This is particularly
present in the help/setup sections at the end of this text file.


I don't think this format accomplishes those goals, but it seems like a cool
experiment/stepping stone towards something cool.


The scheme/type:

# A comment.
# A data type with a single constructor broken across multiple
# lines
# The first word is the constructor name and the rest define parameters
# Each parameter of the constructor is named.
Widget = ProcessorUsage (n Int) (pct Double)
       | MemoryUsage (used Double) (total Double)
       | Tasks (numTasks Int) (thr Int) (numRunning Int)
       | ...

ProcessorUsage display as
    {fstring -string "$n", ProgressBar -percent pct}

MemoryUsage display as
    {fstring -string "Mem", ProgressBar -numerator used -denominator total}

Tasks display as
    fstring -string "Tasks: $numTasks, $thr thr; $numRunning running"


Process = ProcessC
    (PID Ind)
    (USER String)
    # The ! means that the user can change the integer
    # Even if ProcessC as a whole isn't marked as interactive, this element will
    # be.
    (PRI !Int)
    (NI !Int)
    (VIRT Int -unit: "Byte")
    ...
    (TIME Time -precision: "Seconds")
    ...

# If a Process is marked as interactive, treat it like an interactive unit type.
# That means the only thing you can do to it is click on it.
Process Interact as
    # the action flag provides a name for the interaction.
    {} -action "End Process"

# Help should be embedded into the UI to improve accessibility, not given as a
# separate page. For that reason, help is missing.
# Setup should also exist somewhat on its own instead of being part of the main
# UI.
Htop {
    # The mostlyConst flag tells the renderer that the list of widgets is
    # dynamic, but that changes are allowed to reflow the entire UI. This lets the
    # renderer delay the UI flow until it has received the contents of the
    # Dashboard. Without the mostlyConst flag, the renderer would have to assume
    # the worst possible case and flow the entire UI around that. Normally, a
    # change in data shouldn't change the flow of the UI. The only thing that can
    # change the flow is a change in the window size.
    Dashboard ![Widget] -mostlyConst

    # Process in marked as interactive. Per the "Interact as" field above, this
    # means the process can be ended. Note that we aren't creating a button to end
    # the process. A renderer might create the button, or generate a CLI flag for
    # triggering the action.
    ProcessList {[!Process] -filter: true -search: true -colSort: true}
}


Data:
{
    Dashboard
        [ ProcessorUsage 1 2.6
        , ProcessorUsage 2 3.5
        , ProcessorUsage 3 1.0
        , ProcessorUsage 4 100.0
        , MemoryUsage 3.07 15.5
        , Tasks 111 400 1
        ]

    ProcessList
        [ ProcessC
            PID 50,
            USER "Jack",
            PRI "2",
            NI "0",
            VIRT "100000",
            ...
            TIME "1980234", #<- Unix time stamp
            ...
        , ProcessC
            PID 51,
            USER "Jack",
            PRI "2",
            NI "0",
            VIRT "100000",
            ...
            TIME "19804", #<- Unix time stamp
            ...
        ...
        ]
}

How does it do it?

Dashboard:
Since the dashboard is mostly constant, we can analyze the data to decide how
much space it should take up. Normally, we would have to assume that it might be
empty one second and filled with a million elements the next. Now though, we can
see that it only has a handful of elements and assign it a specific width and
height.

Process list:
We might have an infinite number of processes with infinitely long columns. This
list will ask for 100% width and 100% height. Since strings can be arbitrarily
long, we'll orient the list vertically to avoid weird horizontal scrolling.

Should the dashboard be to the left or above the process list? Since we know
more about the dashboard, we'll focus on that one. Since the text largely fits
on half a screen and progress bars don't get a lot of benefit from being
exceptionally wide, we can likely orient the dashboard list as a kind of grid.
After doing that, We can see that the width of the dashboard is larger than the
height. It also can use 100% of the width but can't use 100% of the height. That
means we can give the process list (which asks for 100% in both dimensions) more
of its requested space and we can avoid excessive whitespace by arranging things
vertically.

Although the above paragraph is pretty handwavy, it hopefully gives an idea
about why a renderer might pick a certain orientation for elements. Imagine if
the dashboard were extremely large and none of the elements were very wide. If
the terminal screen were large enough, it might make sense to put the dashboard
horizontal to the process list and have it scroll vertically parallel to the
process list.



What's different?

Instead of faithfully recreating the htop interface, I will instead make a case
that the existing interface is suboptimal and that the version described above
improves upon it. The process list stays mostly the same, but the dashboard has
gotten a big change.

First, the dashboard doesn't scale as your terminal width changes. That means
text will get cut off and become unreadable because it's trying to fit two
columns into a space where only one is available. It also doesn't scale up.
Instead, it makes the progress bars really large which doesn't provide that much
more information. The text based items don't get any extra information and just
waste a lot of space. In addition, imagine if you had a translation that made
some of the textual representations extremely large. In that case, you wouldn't
want two columns because it would cut off text.

This description also moves the help and setup into a separate (unwritten) part
of the standard. The current help page reads like a colorful man page. Although
useful, it could be improved. For one, it disconnects the help text from the
elements it provides help for. This hurts discoverability and accessibility.
Imagine a user that's interacting with the computer in a non-standard way. If
a piece of help text were associated with the button or element it provided help
for, then a screen reader could provide context on how the element could be
used.

Moving help text to a more generic format has other benefits. You could use it
to generate help pages in a variety of formats (man page, html doc, pdf, etc.),
you could provide animations or automatically generated screenshots, or you
could use it to create a form of macros.

To explain the macro comment a bit more, imagine if you search through the help
page for how to do X. In most systems, you now have to switch between multiple
windows to follow the steps. Instead, you could click a button on the help page
and the app would actually show you how to navigate to and use the feature you
want.

The setup is also unwritten. Basically, it's a separate piece of data that the
renderer will integrate with your UI somehow. Apps can use the renderer protocol
to extract the settings at startup and adjust behavior accordingly. One cool
benefit is that programs no longer have to deal with argument parsing or reading
config file formats. From a user's point of view, all configuration will be saved
in plain text in an easy to find location by the renderer. You could toss some
kind of syncing on that directory to get your preferences shared across devices.

This also lets you control how preferences are loaded. If the program didn't use
this UI system, it might not support sharing one config file across devices. For
example, you might have one setting turned on for you phone but off on your
desktop. The rest of the settings are the same. The renderer could detect which
device you're using and send different options based on how you've configured
it.
