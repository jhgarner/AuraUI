Central Ideas:
 * The file format is loosely JSON.
 * elements in a dictionary can either have a value or not. 
 * Data is lazily loaded.
 * One element is designated as focused.
 * Any element can be interactive.
 * Groupings can be created using list syntax.

??? = Thunk of data. If the renderer needs to render it, the client will be
contacted.
* = Focused element. The one line that starts with * represents what should be
focused.
... = I'm lazy.


There are two programs running: Discord and the renderer. The two are
communicating using you favorite form of IPC. The Discord program is completely
headless and has no idea if it's even running on a machine with a screen. The
renderer is running locally.

Discord starts up and somehow discovers the rendering server. It starts by
sending the following:

{
  "Dashboard" ->
  {
    ...
  }
  ???*
  [
    "New" ->
    {
      ...
    }
    "Search" ->
    {
      ...
    }
  ]
}


The renderer will see the root {} and will
recognize that there are multiple kv pairs inside of it. It will also see the
??? Which tell it that the number of options is unknown. As a result, it will
create a vertical tab list where the keys are the things on the tabs and the
values are the things in the tabs. Which tab should actually be drawn? That is
decided by the focus. Since the focused element is ???, it needs to request
evaluation of the thunk. It sends the following to Discord.

{"Thunk": "[1]"}

Although I'm using real JSON, this could be in a variety of formats.

Discord then responds with:


[
  "MGAM" -> ???*
  "MMS" -> ???
]

Which is inserted into the spot that had the ???. Note that the * moved to be
nested even more. The square brackets signify that things are semantically
grouped together but are not different from their non bracketed siblings. A
renderer might decide to put thin horizontal lines between bracket groups.
Leaving brackets off something is the same as putting brackets around 1 thing.

Like before, another thunk will be requested. The following communication
occurs:

{"Thunk": "[1].MGAM"}


{
  {name: "general", !invite: "s3.a.b", ...} -> ???*,
  "idk" -> ???
}

Like before, Discord's response is inserted into the ???. Since this is the
right side of the "MGAM" arrow, this represents the tab's contents. The contents
are nested tabs where the key is
itself a dictionary. TODO How does it know to display those keys in the right
order with good sizes?

The ! Syntax means that the element can be interacted with somehow and we want
to be notified if it is.

Only one tab is rendered at a time according to this
renderer so the question marks after "idk" will remain thunked.

{"Thunk": "[1].MGAM.{name: "general", ...}"}

{
  {[sign: "s3.com/hashtag.png", name: "general"], [!bell: "s3.com/bell.png, ...]},
  [
    ???,
    {avatar: "s3.aws.com/discord/jkrmnj", userName: "jkrmnj", Date: "Today"} ->
      ["Test", "Message 2", "M3"],
    {avatar: "s3.aws.com/discord/Zatton", userName: "Zatton", Date: "Yesterday"} ->
      ["Another Test\n\ntest"]
  ],
  {!attach: "s3.com", *!message: "", ...}
}

The first element in the response is wrapped in more {}. This means it has
tab-like things inside. Since there are no question marks in that structure, we
know there are a fixed number of tabs. That gets interpreted as a horizontal tab
bar. Since none of these tabs have values, clicking them doesn't do much.

The second group of things are the messages. The question marks here are a thunk
for the previous messages. If the user were to scroll up, the renderer would
want to render those elements. For now though, we don't need them.

Since we've finally found a focused element, we can actually render things
without needing to worry about thunks.



===============================================================================
Importance:



Values are sized based on a hierarchy:
(Header# -> SubHeader -> UI <-> Body -> Caption) <-> Raw
There should be at most # of headers on a given screen. SubHeaders need to be
associated with a Header and there can only be 1 per header. UI means that Raw means the
developer has no idea what size something is and the user probably picked it.

Collections cannot be sized. They take on the size of their contents.

Keys are sized based on the tab density that's desired.
